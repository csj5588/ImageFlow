'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _templateObject = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 2.;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform float power; // = 5.0\n\n      vec4 transition(vec2 p) {\n        vec4 fTex = getFromColor(p);\n        vec4 tTex = getToColor(p);\n        float m = step(distance(fTex, tTex), progress);\n        return mix(\n          mix(fTex, tTex, m),\n          tTex,\n          pow(progress, power)\n        );\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 2.;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform float power; // = 5.0\n\n      vec4 transition(vec2 p) {\n        vec4 fTex = getFromColor(p);\n        vec4 tTex = getToColor(p);\n        float m = step(distance(fTex, tTex), progress);\n        return mix(\n          mix(fTex, tTex, m),\n          tTex,\n          pow(progress, power)\n        );\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject2 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 1.;\n      float progress = abs(sin(Time)) / duration;\n      // float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      vec4 transition(vec2 p) {\n        float x = progress;\n        x=smoothstep(.0,1.0,(x*2.0+p.x-1.0));\n        return mix(getFromColor((p-.5)*(1.-x)+.5), getToColor((p-.5)*x+.5), x);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 1.;\n      float progress = abs(sin(Time)) / duration;\n      // float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      vec4 transition(vec2 p) {\n        float x = progress;\n        x=smoothstep(.0,1.0,(x*2.0+p.x-1.0));\n        return mix(getFromColor((p-.5)*(1.-x)+.5), getToColor((p-.5)*x+.5), x);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject3 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform float strength; // = 0.4\n\n      const float PI = 3.141592653589793;\n\n      float Linear_ease(in float begin, in float change, in float duration, in float time) {\n        return change * time / duration + begin;\n      }\n\n      float Exponential_easeInOut(in float begin, in float change, in float duration, in float time) {\n        if (time == 0.0)\n          return begin;\n        else if (time == duration)\n          return begin + change;\n        time = time / (duration / 2.0);\n        if (time < 1.0)\n          return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin;\n        return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;\n      }\n\n      float Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float time) {\n        return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;\n      }\n\n      float rand (vec2 co) {\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n      }\n\n      vec3 crossFade(in vec2 uv, in float dissolve) {\n        return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);\n      }\n\n      vec4 transition(vec2 uv) {\n        vec2 texCoord = uv.xy / vec2(1.0).xy;\n\n        // Linear interpolate center across center half of the image\n        vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5);\n        float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress);\n\n        // Mirrored sinusoidal loop. 0->strength then strength->0\n        float strength = Sinusoidal_easeInOut(0.0, strength, 0.5, progress);\n\n        vec3 color = vec3(0.0);\n        float total = 0.0;\n        vec2 toCenter = center - texCoord;\n\n        /* randomize the lookup values to hide the fixed number of samples */\n        float offset = rand(uv);\n\n        for (float t = 0.0; t <= 40.0; t++) {\n            float percent = (t + offset) / 40.0;\n            float weight = 4.0 * (percent - percent * percent);\n            color += crossFade(texCoord + toCenter * percent * strength, dissolve) * weight;\n            total += weight;\n        }\n        return vec4(color / total, 1.0);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform float strength; // = 0.4\n\n      const float PI = 3.141592653589793;\n\n      float Linear_ease(in float begin, in float change, in float duration, in float time) {\n        return change * time / duration + begin;\n      }\n\n      float Exponential_easeInOut(in float begin, in float change, in float duration, in float time) {\n        if (time == 0.0)\n          return begin;\n        else if (time == duration)\n          return begin + change;\n        time = time / (duration / 2.0);\n        if (time < 1.0)\n          return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin;\n        return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;\n      }\n\n      float Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float time) {\n        return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;\n      }\n\n      float rand (vec2 co) {\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n      }\n\n      vec3 crossFade(in vec2 uv, in float dissolve) {\n        return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);\n      }\n\n      vec4 transition(vec2 uv) {\n        vec2 texCoord = uv.xy / vec2(1.0).xy;\n\n        // Linear interpolate center across center half of the image\n        vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5);\n        float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress);\n\n        // Mirrored sinusoidal loop. 0->strength then strength->0\n        float strength = Sinusoidal_easeInOut(0.0, strength, 0.5, progress);\n\n        vec3 color = vec3(0.0);\n        float total = 0.0;\n        vec2 toCenter = center - texCoord;\n\n        /* randomize the lookup values to hide the fixed number of samples */\n        float offset = rand(uv);\n\n        for (float t = 0.0; t <= 40.0; t++) {\n            float percent = (t + offset) / 40.0;\n            float weight = 4.0 * (percent - percent * percent);\n            color += crossFade(texCoord + toCenter * percent * strength, dissolve) * weight;\n            total += weight;\n        }\n        return vec4(color / total, 1.0);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject4 = _taggedTemplateLiteral(['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n\n      void main (void) {\n        float duration = 0.7;\n        float maxScale = 1.1;\n        float offset = 0.02;\n\n        float progress = mod(Time, duration) / duration;\n        vec2 offsetCoords = vec2(offset, offset) * progress;\n        float scale = 1.0 + (maxScale - 1.0) * progress;\n\n        vec2 ScaleTextureCoords = vec2(0.5, 0.5) + (uv - vec2(0.5, 0.5)) / scale;\n\n        vec4 maskR = texture2D(Texture, ScaleTextureCoords + offsetCoords);\n        vec4 maskB = texture2D(Texture, ScaleTextureCoords - offsetCoords);\n        vec4 mask = texture2D(Texture, ScaleTextureCoords);\n\n        gl_FragColor = vec4(maskR.r, mask.g, maskB.b, mask.a);\n      }\n  '], ['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n\n      void main (void) {\n        float duration = 0.7;\n        float maxScale = 1.1;\n        float offset = 0.02;\n\n        float progress = mod(Time, duration) / duration;\n        vec2 offsetCoords = vec2(offset, offset) * progress;\n        float scale = 1.0 + (maxScale - 1.0) * progress;\n\n        vec2 ScaleTextureCoords = vec2(0.5, 0.5) + (uv - vec2(0.5, 0.5)) / scale;\n\n        vec4 maskR = texture2D(Texture, ScaleTextureCoords + offsetCoords);\n        vec4 maskB = texture2D(Texture, ScaleTextureCoords - offsetCoords);\n        vec4 mask = texture2D(Texture, ScaleTextureCoords);\n\n        gl_FragColor = vec4(maskR.r, mask.g, maskB.b, mask.a);\n      }\n  ']),
    _templateObject5 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 1.;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.), min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.), min(_fromR/_toR,1.)));\n      }\n\n      vec2 offset(float progress, float x, float theta) {\n        float phase = progress*progress + progress + theta;\n        float shifty = 0.03*progress*cos(10.0*(progress+x));\n        return vec2(0, shifty);\n      }\n      vec4 transition(vec2 p) {\n        return mix(getFromColor(p + offset(progress, p.x, 0.0)), getToColor(p + offset(1.0-progress, p.x, 3.14)), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 1.;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.), min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.), min(_fromR/_toR,1.)));\n      }\n\n      vec2 offset(float progress, float x, float theta) {\n        float phase = progress*progress + progress + theta;\n        float shifty = 0.03*progress*cos(10.0*(progress+x));\n        return vec2(0, shifty);\n      }\n      vec4 transition(vec2 p) {\n        return mix(getFromColor(p + offset(progress, p.x, 0.0)), getToColor(p + offset(1.0-progress, p.x, 3.14)), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject6 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      const float size = 0.04;\n      const float zoom  = 50.0;\n      const float colorSeparation = 0.3;\n\n      vec4 transition(vec2 p) {\n        float inv = 1. - progress;\n        vec2 disp = size*vec2(cos(zoom*p.x), sin(zoom*p.y));\n        vec4 texTo = getToColor(p + inv*disp);\n        vec4 texFrom = vec4(\n          getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,\n          getFromColor(p + progress*disp).g,\n          getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,\n          1.0);\n        return texTo*progress + texFrom*inv;\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      const float size = 0.04;\n      const float zoom  = 50.0;\n      const float colorSeparation = 0.3;\n\n      vec4 transition(vec2 p) {\n        float inv = 1. - progress;\n        vec2 disp = size*vec2(cos(zoom*p.x), sin(zoom*p.y));\n        vec4 texTo = getToColor(p + inv*disp);\n        vec4 texFrom = vec4(\n          getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,\n          getFromColor(p + progress*disp).g,\n          getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,\n          1.0);\n        return texTo*progress + texFrom*inv;\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject7 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      highp float random(vec2 co) {\n        highp float a = 12.9898;\n        highp float b = 78.233;\n        highp float c = 43758.5453;\n        highp float dt= dot(co.xy ,vec2(a,b));\n        highp float sn= mod(dt,3.14);\n        return fract(sin(sn) * c);\n      }\n      float voronoi( in vec2 x ) {\n        vec2 p = floor( x );\n        vec2 f = fract( x );\n        float res = 8.0;\n        for(float j=-1.; j<=1.; j++)\n        for(float i=-1.; i<=1.; i++) {\n          vec2  b = vec2( i, j );\n          vec2  r = b - f + random( p + b );\n          float d = dot( r, r );\n          res = min( res, d );\n        }\n        return sqrt( res );\n      }\n\n      vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) {\n        float b = voronoi(.003 * texCoord + 2.0);\n        float g = voronoi(0.2 * texCoord);\n        float r = voronoi(texCoord - 1.0);\n        vec4 dt = tex * 1.0;\n        vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth;\n\n        dis.x = dis.x - 1.0 + textureDepth*dotDepth;\n        dis.y = dis.y - 1.0 + textureDepth*dotDepth;\n        dis.x *= strength;\n        dis.y *= strength;\n        vec2 res_uv = texCoord ;\n        res_uv.x = res_uv.x + dis.x - 0.0;\n        res_uv.y = res_uv.y + dis.y;\n        return res_uv;\n      }\n\n      float ease1(float t) {\n        return t == 0.0 || t == 1.0\n          ? t\n          : t < 0.5\n            ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n            : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n      }\n      float ease2(float t) {\n        return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n      }\n\n      vec4 transition(vec2 uv) {\n        vec2 p = uv.xy / vec2(1.0).xy;\n        vec4 color1 = getFromColor(p);\n        vec4 color2 = getToColor(p);\n        vec2 disp = displace(color1, p, 0.33, 0.7, 1.0-ease1(progress));\n        vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress));\n        vec4 dColor1 = getToColor(disp);\n        vec4 dColor2 = getFromColor(disp2);\n        float val = ease1(progress);\n        vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114)));\n        dColor2 = vec4(gray, 1.0);\n        dColor2 *= 2.0;\n        color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress));\n        color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress));\n        return mix(color1, color2, val);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      highp float random(vec2 co) {\n        highp float a = 12.9898;\n        highp float b = 78.233;\n        highp float c = 43758.5453;\n        highp float dt= dot(co.xy ,vec2(a,b));\n        highp float sn= mod(dt,3.14);\n        return fract(sin(sn) * c);\n      }\n      float voronoi( in vec2 x ) {\n        vec2 p = floor( x );\n        vec2 f = fract( x );\n        float res = 8.0;\n        for(float j=-1.; j<=1.; j++)\n        for(float i=-1.; i<=1.; i++) {\n          vec2  b = vec2( i, j );\n          vec2  r = b - f + random( p + b );\n          float d = dot( r, r );\n          res = min( res, d );\n        }\n        return sqrt( res );\n      }\n\n      vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) {\n        float b = voronoi(.003 * texCoord + 2.0);\n        float g = voronoi(0.2 * texCoord);\n        float r = voronoi(texCoord - 1.0);\n        vec4 dt = tex * 1.0;\n        vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth;\n\n        dis.x = dis.x - 1.0 + textureDepth*dotDepth;\n        dis.y = dis.y - 1.0 + textureDepth*dotDepth;\n        dis.x *= strength;\n        dis.y *= strength;\n        vec2 res_uv = texCoord ;\n        res_uv.x = res_uv.x + dis.x - 0.0;\n        res_uv.y = res_uv.y + dis.y;\n        return res_uv;\n      }\n\n      float ease1(float t) {\n        return t == 0.0 || t == 1.0\n          ? t\n          : t < 0.5\n            ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n            : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n      }\n      float ease2(float t) {\n        return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n      }\n\n      vec4 transition(vec2 uv) {\n        vec2 p = uv.xy / vec2(1.0).xy;\n        vec4 color1 = getFromColor(p);\n        vec4 color2 = getToColor(p);\n        vec2 disp = displace(color1, p, 0.33, 0.7, 1.0-ease1(progress));\n        vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress));\n        vec4 dColor1 = getToColor(disp);\n        vec4 dColor2 = getFromColor(disp2);\n        float val = ease1(progress);\n        vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114)));\n        dColor2 = vec4(gray, 1.0);\n        dColor2 *= 2.0;\n        color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress));\n        color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress));\n        return mix(color1, color2, val);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject8 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      vec4 transition(vec2 p) {\n        vec2 block = floor(p.xy / vec2(16));\n        vec2 uv_noise = block / vec2(64);\n        uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);\n        vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);\n        vec2 red = p + dist * 0.2;\n        vec2 green = p + dist * .3;\n        vec2 blue = p + dist * .5;\n      \n        return vec4(mix(getFromColor(red), getToColor(red), progress).r,mix(getFromColor(green), getToColor(green), progress).g,mix(getFromColor(blue), getToColor(blue), progress).b,1.0);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      vec4 transition(vec2 p) {\n        vec2 block = floor(p.xy / vec2(16));\n        vec2 uv_noise = block / vec2(64);\n        uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);\n        vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);\n        vec2 red = p + dist * 0.2;\n        vec2 green = p + dist * .3;\n        vec2 blue = p + dist * .5;\n      \n        return vec4(mix(getFromColor(red), getToColor(red), progress).r,mix(getFromColor(green), getToColor(green), progress).g,mix(getFromColor(blue), getToColor(blue), progress).b,1.0);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject9 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 1.;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform int steps;\n      uniform float horizontalHexagons;\n\n      struct Hexagon {\n        float q;\n        float r;\n        float s;\n      };\n\n      Hexagon createHexagon(float q, float r){\n        Hexagon hex;\n        hex.q = q;\n        hex.r = r;\n        hex.s = -q - r;\n        return hex;\n      }\n\n      Hexagon roundHexagon(Hexagon hex){\n        float q = floor(hex.q + 0.5);\n        float r = floor(hex.r + 0.5);\n        float s = floor(hex.s + 0.5);\n        float deltaQ = abs(q - hex.q);\n        float deltaR = abs(r - hex.r);\n        float deltaS = abs(s - hex.s);\n        if (deltaQ > deltaR && deltaQ > deltaS)\n          q = -r - s;\n        else if (deltaR > deltaS)\n          r = -q - s;\n        else\n          s = -q - r;\n        return createHexagon(q, r);\n      }\n\n      Hexagon hexagonFromPoint(vec2 point, float size) {\n        point.y /= ratio;\n        point = (point - 0.5) / size;\n        float q = (sqrt(3.0) / 3.0) * point.x + (-1.0 / 3.0) * point.y;\n        float r = 0.0 * point.x + 2.0 / 3.0 * point.y;\n        Hexagon hex = createHexagon(q, r);\n        return roundHexagon(hex);\n      }\n\n      vec2 pointFromHexagon(Hexagon hex, float size) {\n        float x = (sqrt(3.0) * hex.q + (sqrt(3.0) / 2.0) * hex.r) * size + 0.5;\n        float y = (0.0 * hex.q + (3.0 / 2.0) * hex.r) * size + 0.5;\n        return vec2(x, y * ratio);\n      }\n\n      vec4 transition (vec2 uv) {\n        float dist = 2.0 * min(progress, 1.0 - progress);\n        dist = steps > 0 ? ceil(dist * float(steps)) / float(steps) : dist;\n        float size = (sqrt(3.0) / 3.0) * dist / horizontalHexagons;\n        vec2 point = dist > 0.0 ? pointFromHexagon(hexagonFromPoint(uv, size), size) : uv;\n        return mix(getFromColor(point), getToColor(point), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 1.;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform int steps;\n      uniform float horizontalHexagons;\n\n      struct Hexagon {\n        float q;\n        float r;\n        float s;\n      };\n\n      Hexagon createHexagon(float q, float r){\n        Hexagon hex;\n        hex.q = q;\n        hex.r = r;\n        hex.s = -q - r;\n        return hex;\n      }\n\n      Hexagon roundHexagon(Hexagon hex){\n        float q = floor(hex.q + 0.5);\n        float r = floor(hex.r + 0.5);\n        float s = floor(hex.s + 0.5);\n        float deltaQ = abs(q - hex.q);\n        float deltaR = abs(r - hex.r);\n        float deltaS = abs(s - hex.s);\n        if (deltaQ > deltaR && deltaQ > deltaS)\n          q = -r - s;\n        else if (deltaR > deltaS)\n          r = -q - s;\n        else\n          s = -q - r;\n        return createHexagon(q, r);\n      }\n\n      Hexagon hexagonFromPoint(vec2 point, float size) {\n        point.y /= ratio;\n        point = (point - 0.5) / size;\n        float q = (sqrt(3.0) / 3.0) * point.x + (-1.0 / 3.0) * point.y;\n        float r = 0.0 * point.x + 2.0 / 3.0 * point.y;\n        Hexagon hex = createHexagon(q, r);\n        return roundHexagon(hex);\n      }\n\n      vec2 pointFromHexagon(Hexagon hex, float size) {\n        float x = (sqrt(3.0) * hex.q + (sqrt(3.0) / 2.0) * hex.r) * size + 0.5;\n        float y = (0.0 * hex.q + (3.0 / 2.0) * hex.r) * size + 0.5;\n        return vec2(x, y * ratio);\n      }\n\n      vec4 transition (vec2 uv) {\n        float dist = 2.0 * min(progress, 1.0 - progress);\n        dist = steps > 0 ? ceil(dist * float(steps)) / float(steps) : dist;\n        float size = (sqrt(3.0) / 3.0) * dist / horizontalHexagons;\n        vec2 point = dist > 0.0 ? pointFromHexagon(hexagonFromPoint(uv, size), size) : uv;\n        return mix(getFromColor(point), getToColor(point), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject10 = _taggedTemplateLiteral(['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n      \n      void main (void) {\n        float duration = 0.7;\n        float maxAlpha = 0.8;\n        float maxScale = 1.1;\n        \n        float progress = mod(Time, duration) / duration;\n        float alpha = maxAlpha * (1.0 - progress);\n        float scale = 1.0 + (maxScale - 1.0) * progress;\n\n        float weakX = 0.5 + (uv.x - 0.5) / scale;\n        float weakY = 0.5 + (uv.y - 0.5) / scale;\n\n        vec2 weakTextureCoords = vec2(weakX, weakY);\n\n        vec4 weakMask = texture2D(Texture, weakTextureCoords);\n       \n        vec4 mask = texture2D(Texture, uv);\n        \n        gl_FragColor = mask * (1.0 - alpha) + weakMask * alpha;\n      }\n  '], ['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n      \n      void main (void) {\n        float duration = 0.7;\n        float maxAlpha = 0.8;\n        float maxScale = 1.1;\n        \n        float progress = mod(Time, duration) / duration;\n        float alpha = maxAlpha * (1.0 - progress);\n        float scale = 1.0 + (maxScale - 1.0) * progress;\n\n        float weakX = 0.5 + (uv.x - 0.5) / scale;\n        float weakY = 0.5 + (uv.y - 0.5) / scale;\n\n        vec2 weakTextureCoords = vec2(weakX, weakY);\n\n        vec4 weakMask = texture2D(Texture, weakTextureCoords);\n       \n        vec4 mask = texture2D(Texture, uv);\n        \n        gl_FragColor = mask * (1.0 - alpha) + weakMask * alpha;\n      }\n  ']),
    _templateObject11 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform bool direction; // = 1 \n      uniform float l_threshold; // = 0.8 \n      uniform bool above; // = false \n\n      float rand(vec2 co){\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n      }\n\n      vec3 mod289(vec3 x) {\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec2 mod289(vec2 x) {\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec3 permute(vec3 x) {\n        return mod289(((x*34.0)+1.0)*x);\n      }\n\n      float snoise(vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                          -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n\n        vec2 i1;\n\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n          + i.x + vec3(0.0, i1.x, 1.0 ));\n\n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n\n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n\n        // Normalise gradients implicitly by scaling m\n        // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n        // Compute final noise value at P\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n      }\n\n      float luminance(vec4 color) {\n        return color.r*0.299+color.g*0.587+color.b*0.114;\n      }\n\n      vec2 center = vec2(1.0, direction);\n\n      vec4 transition(vec2 uv) {\n        vec2 p = uv.xy / vec2(1.0).xy;\n        if (progress == 0.0) {\n          return getFromColor(p);\n        } else if (progress == 1.0) {\n          return getToColor(p);\n        } else {\n          float x = progress;\n          float dist = distance(center, p)- progress*exp(snoise(vec2(p.x, 0.0)));\n          float r = x - rand(vec2(p.x, 0.1));\n          float m;\n          if(above){\n          m = dist <= r && luminance(getFromColor(p))>l_threshold ? 1.0 : (progress*progress*progress);\n          }\n          else{\n          m = dist <= r && luminance(getFromColor(p))<l_threshold ? 1.0 : (progress*progress*progress);  \n          }\n          return mix(getFromColor(p), getToColor(p), m);    \n        }\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = abs(sin(Time)) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform bool direction; // = 1 \n      uniform float l_threshold; // = 0.8 \n      uniform bool above; // = false \n\n      float rand(vec2 co){\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n      }\n\n      vec3 mod289(vec3 x) {\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec2 mod289(vec2 x) {\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec3 permute(vec3 x) {\n        return mod289(((x*34.0)+1.0)*x);\n      }\n\n      float snoise(vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                          -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n\n        vec2 i1;\n\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n          + i.x + vec3(0.0, i1.x, 1.0 ));\n\n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n\n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n\n        // Normalise gradients implicitly by scaling m\n        // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n        // Compute final noise value at P\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n      }\n\n      float luminance(vec4 color) {\n        return color.r*0.299+color.g*0.587+color.b*0.114;\n      }\n\n      vec2 center = vec2(1.0, direction);\n\n      vec4 transition(vec2 uv) {\n        vec2 p = uv.xy / vec2(1.0).xy;\n        if (progress == 0.0) {\n          return getFromColor(p);\n        } else if (progress == 1.0) {\n          return getToColor(p);\n        } else {\n          float x = progress;\n          float dist = distance(center, p)- progress*exp(snoise(vec2(p.x, 0.0)));\n          float r = x - rand(vec2(p.x, 0.1));\n          float m;\n          if(above){\n          m = dist <= r && luminance(getFromColor(p))>l_threshold ? 1.0 : (progress*progress*progress);\n          }\n          else{\n          m = dist <= r && luminance(getFromColor(p))<l_threshold ? 1.0 : (progress*progress*progress);  \n          }\n          return mix(getFromColor(p), getToColor(p), m);    \n        }\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject12 = _taggedTemplateLiteral(['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      \n      uniform float Time;\n      \n      const float PI = 3.1415926;\n      const float duration = 2.0;\n      \n      vec4 getMask(float time, vec2 textureCoords, float padding) {\n        vec2 translation = vec2(sin(time * (PI * 2.0 / duration)),cos(time * (PI * 2.0 / duration)));\n        vec2 translationTextureCoords = textureCoords + padding * translation;\n        vec4 mask = texture2D(Texture, translationTextureCoords);\n        return mask;\n      }\n\n      float maskAlphaProgress(float currentTime, float hideTime, float startTime) {\n        float time = mod(duration + currentTime - startTime, duration);\n        return min(time, hideTime);\n      }\n      \n      void main(){\n        float time = mod(Time, duration);\n        float scale = 1.2;\n        float padding = 0.5 * (1.0 - 1.0 / scale);\n        vec2 textureCoords = vec2(0.5, 0.5) + (uv - vec2(0.5, 0.5)) / scale;\n    \n        float hideTime = 0.9;\n        float timeGap = 0.2;\n    \n        float maxAlphaR = 0.5;\n        float maxAlphaG = 0.05;\n        float maxAlphaB = 0.05;\n\n        vec4 mask = getMask(time, textureCoords, padding);\n        float alphaR = 1.0;\n        float alphaG = 1.0;\n        float alphaB = 1.0;\n    \n        vec4 resultMask = vec4(0, 0, 0, 0);\n    \n        for (float f = 0.0; f < 2.0; f += 0.2) {\n          float tmpTime = f;\n          vec4 tmpMask = getMask(tmpTime, textureCoords, padding);\n  \n          float tmpAlphaR = maxAlphaR - maxAlphaR * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;\n          float tmpAlphaG = maxAlphaG - maxAlphaG * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;\n          float tmpAlphaB = maxAlphaB - maxAlphaB * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;\n  \n          resultMask += vec4(tmpMask.r * tmpAlphaR,tmpMask.g * tmpAlphaG,tmpMask.b * tmpAlphaB,1.0);\n\n          alphaR -= tmpAlphaR;\n          alphaG -= tmpAlphaG;\n          alphaB -= tmpAlphaB;\n        }\n    \n        resultMask += vec4(mask.r * alphaR, mask.g * alphaG, mask.b * alphaB, 1.0);\n    \n        gl_FragColor = resultMask;\n      }\n  '], ['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      \n      uniform float Time;\n      \n      const float PI = 3.1415926;\n      const float duration = 2.0;\n      \n      vec4 getMask(float time, vec2 textureCoords, float padding) {\n        vec2 translation = vec2(sin(time * (PI * 2.0 / duration)),cos(time * (PI * 2.0 / duration)));\n        vec2 translationTextureCoords = textureCoords + padding * translation;\n        vec4 mask = texture2D(Texture, translationTextureCoords);\n        return mask;\n      }\n\n      float maskAlphaProgress(float currentTime, float hideTime, float startTime) {\n        float time = mod(duration + currentTime - startTime, duration);\n        return min(time, hideTime);\n      }\n      \n      void main(){\n        float time = mod(Time, duration);\n        float scale = 1.2;\n        float padding = 0.5 * (1.0 - 1.0 / scale);\n        vec2 textureCoords = vec2(0.5, 0.5) + (uv - vec2(0.5, 0.5)) / scale;\n    \n        float hideTime = 0.9;\n        float timeGap = 0.2;\n    \n        float maxAlphaR = 0.5;\n        float maxAlphaG = 0.05;\n        float maxAlphaB = 0.05;\n\n        vec4 mask = getMask(time, textureCoords, padding);\n        float alphaR = 1.0;\n        float alphaG = 1.0;\n        float alphaB = 1.0;\n    \n        vec4 resultMask = vec4(0, 0, 0, 0);\n    \n        for (float f = 0.0; f < 2.0; f += 0.2) {\n          float tmpTime = f;\n          vec4 tmpMask = getMask(tmpTime, textureCoords, padding);\n  \n          float tmpAlphaR = maxAlphaR - maxAlphaR * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;\n          float tmpAlphaG = maxAlphaG - maxAlphaG * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;\n          float tmpAlphaB = maxAlphaB - maxAlphaB * maskAlphaProgress(time, hideTime, tmpTime) / hideTime;\n  \n          resultMask += vec4(tmpMask.r * tmpAlphaR,tmpMask.g * tmpAlphaG,tmpMask.b * tmpAlphaB,1.0);\n\n          alphaR -= tmpAlphaR;\n          alphaG -= tmpAlphaG;\n          alphaB -= tmpAlphaB;\n        }\n    \n        resultMask += vec4(mask.r * alphaR, mask.g * alphaG, mask.b * alphaB, 1.0);\n    \n        gl_FragColor = resultMask;\n      }\n  ']),
    _templateObject13 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 2.;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform float strength; // = 0.1\n\n      vec4 transition(vec2 p) {\n        vec4 ca = getFromColor(p);\n        vec4 cb = getToColor(p);\n        \n        vec2 oa = (((ca.rg+ca.b)*0.5)*2.0-1.0);\n        vec2 ob = (((cb.rg+cb.b)*0.5)*2.0-1.0);\n        vec2 oc = mix(oa,ob,0.5)*strength;\n        \n        float w0 = progress;\n        float w1 = 1.0-w0;\n        return mix(getFromColor(p+oc*w0), getToColor(p-oc*w1), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 2.;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      uniform float strength; // = 0.1\n\n      vec4 transition(vec2 p) {\n        vec4 ca = getFromColor(p);\n        vec4 cb = getToColor(p);\n        \n        vec2 oa = (((ca.rg+ca.b)*0.5)*2.0-1.0);\n        vec2 ob = (((cb.rg+cb.b)*0.5)*2.0-1.0);\n        vec2 oc = mix(oa,ob,0.5)*strength;\n        \n        float w0 = progress;\n        float w1 = 1.0-w0;\n        return mix(getFromColor(p+oc*w0), getToColor(p-oc*w1), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject14 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      const ivec2 squaresMin = ivec2(20);\n      const int steps = 50;\n\n      float d = min(progress, 1.0 - progress);\n      float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;\n      vec2 squareSize = 2.0 * dist / vec2(squaresMin);\n\n      vec4 transition(vec2 uv) {\n        vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv;\n        return mix(getFromColor(p), getToColor(p), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 0.7;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      const ivec2 squaresMin = ivec2(20);\n      const int steps = 50;\n\n      float d = min(progress, 1.0 - progress);\n      float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;\n      vec2 squareSize = 2.0 * dist / vec2(squaresMin);\n\n      vec4 transition(vec2 uv) {\n        vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv;\n        return mix(getFromColor(p), getToColor(p), progress);\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject15 = _taggedTemplateLiteral(['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n\n      void main (void) {\n        float duration = 0.6;\n        float time = mod(Time, duration);\n        vec4 whiteMask = vec4(1.0, 1.0, 1.0, 1.0);\n        float amplitude = abs(sin(time * (3.1516 / duration)));\n        vec4 mask = texture2D(Texture, uv);\n        \n        gl_FragColor = mask * (1.0 - amplitude) + whiteMask * amplitude;\n      }\n  '], ['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n\n      void main (void) {\n        float duration = 0.6;\n        float time = mod(Time, duration);\n        vec4 whiteMask = vec4(1.0, 1.0, 1.0, 1.0);\n        float amplitude = abs(sin(time * (3.1516 / duration)));\n        vec4 mask = texture2D(Texture, uv);\n        \n        gl_FragColor = mask * (1.0 - amplitude) + whiteMask * amplitude;\n      }\n  ']),
    _templateObject16 = _taggedTemplateLiteral(['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 8.;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      vec4 transition(vec2 UV) {\n        float Radius = 1.0;\n        float T = progress;\n        UV -= vec2( 0.5, 0.5 );\n        float Dist = length(UV);\n\n        if ( Dist < Radius ) {\n          float Percent = (Radius - Dist) / Radius;\n          float A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );\n          float Theta = Percent * Percent * A * 8.0 * 3.14159;\n          float S = sin( Theta );\n          float C = cos( Theta );\n          UV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );\n        }\n        UV += vec2( 0.5, 0.5 );\n\n        vec4 C0 = getFromColor(UV);\n        vec4 C1 = getToColor(UV);\n\n        return mix( C0, C1, T );\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  '], ['\n      precision highp float;\n      varying vec2 uv;\n      uniform sampler2D from, to;\n      uniform float ratio, _fromR, _toR;\n      uniform float Time;\n      float duration = 8.;\n      float progress = mod(Time, duration) / duration;\n\n      vec4 getFromColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.);\n        return texture2D(from, .5+(uv-.5)*vec2(min(ratio/_fromR, 1.),min(_fromR/ratio,1.)));\n      }\n      vec4 getToColor(vec2 uv) {\n        uv = vec2(1., -1.) * uv + vec2(0., 1.); \n        return texture2D(to, .5+(uv-.5) * vec2(min(ratio/_toR,1.),min(_fromR/_toR,1.)));\n      }\n\n      vec4 transition(vec2 UV) {\n        float Radius = 1.0;\n        float T = progress;\n        UV -= vec2( 0.5, 0.5 );\n        float Dist = length(UV);\n\n        if ( Dist < Radius ) {\n          float Percent = (Radius - Dist) / Radius;\n          float A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );\n          float Theta = Percent * Percent * A * 8.0 * 3.14159;\n          float S = sin( Theta );\n          float C = cos( Theta );\n          UV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );\n        }\n        UV += vec2( 0.5, 0.5 );\n\n        vec4 C0 = getFromColor(UV);\n        vec4 C1 = getToColor(UV);\n\n        return mix( C0, C1, T );\n      }\n      \n      void main() {\n        gl_FragColor = transition(uv);\n      }\n  ']),
    _templateObject17 = _taggedTemplateLiteral(['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n\n      float rand(float n) {\n        return fract(sin(n) * 43758.5453123);\n      }\n      \n      void main (void) {\n        float maxJitter = 0.06;\n        float duration = 0.3;\n        float colorROffset = 0.01;\n        float colorBOffset = -0.025;\n        \n        float time = mod(Time, duration * 2.0);\n        float amplitude = max(sin(time * (3.1415 / duration)), 0.0);\n        \n        float jitter = rand(uv.y) * 2.0 - 1.0;\n        \n        bool needOffset = abs(jitter) < maxJitter * amplitude;\n        \n        float textureX = uv.x + (needOffset ? jitter : (jitter * amplitude * 0.006));\n        \n        vec2 textureCoords = vec2(textureX, uv.y);\n        vec4 mask = texture2D(Texture, textureCoords);\n        vec4 maskR = texture2D(Texture, textureCoords + vec2(colorROffset * amplitude, 0.0));\n        vec4 maskB = texture2D(Texture, textureCoords + vec2(colorBOffset * amplitude, 0.0));\n        \n        gl_FragColor = vec4(maskR.r, mask.g, maskB.b, mask.a);\n      }\n  '], ['\n      precision highp float;\n      uniform sampler2D Texture;\n      varying vec2 uv;\n      uniform float Time;\n\n      float rand(float n) {\n        return fract(sin(n) * 43758.5453123);\n      }\n      \n      void main (void) {\n        float maxJitter = 0.06;\n        float duration = 0.3;\n        float colorROffset = 0.01;\n        float colorBOffset = -0.025;\n        \n        float time = mod(Time, duration * 2.0);\n        float amplitude = max(sin(time * (3.1415 / duration)), 0.0);\n        \n        float jitter = rand(uv.y) * 2.0 - 1.0;\n        \n        bool needOffset = abs(jitter) < maxJitter * amplitude;\n        \n        float textureX = uv.x + (needOffset ? jitter : (jitter * amplitude * 0.006));\n        \n        vec2 textureCoords = vec2(textureX, uv.y);\n        vec4 mask = texture2D(Texture, textureCoords);\n        vec4 maskR = texture2D(Texture, textureCoords + vec2(colorROffset * amplitude, 0.0));\n        vec4 maskB = texture2D(Texture, textureCoords + vec2(colorBOffset * amplitude, 0.0));\n        \n        gl_FragColor = vec4(maskR.r, mask.g, maskB.b, mask.a);\n      }\n  ']);

var _glReact = require('gl-react');

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var shaderConfigs = {
  ColourDistance: {
    frag: (0, _glReact.GLSL)(_templateObject) },
  CrossWrap: {
    frag: (0, _glReact.GLSL)(_templateObject2) },
  CrossZoom: {
    frag: (0, _glReact.GLSL)(_templateObject3) },
  Shake: {
    frag: (0, _glReact.GLSL)(_templateObject4) },
  Dreamy: {
    frag: (0, _glReact.GLSL)(_templateObject5) },
  Flyeye: {
    frag: (0, _glReact.GLSL)(_templateObject6) },
  GlitchDisplace: {
    frag: (0, _glReact.GLSL)(_templateObject7) },
  GlitchMemories: {
    frag: (0, _glReact.GLSL)(_templateObject8) },
  Hexagonalize: {
    frag: (0, _glReact.GLSL)(_templateObject9) },
  Soul: {
    frag: (0, _glReact.GLSL)(_templateObject10) },
  Luminance: {
    frag: (0, _glReact.GLSL)(_templateObject11) },
  Megrim: {
    frag: (0, _glReact.GLSL)(_templateObject12) },
  Morph: {
    frag: (0, _glReact.GLSL)(_templateObject13) },
  Pixlize: {
    frag: (0, _glReact.GLSL)(_templateObject14) },
  Flashing: {
    frag: (0, _glReact.GLSL)(_templateObject15) },
  Swirl: {
    frag: (0, _glReact.GLSL)(_templateObject16) },
  Rag: {
    frag: (0, _glReact.GLSL)(_templateObject17) }
};

exports.default = shaderConfigs;